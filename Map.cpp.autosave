#include <SFML/System.hpp>
#include <SFML/Window.hpp>
#include <SFML/Graphics.hpp>
#include "Map.hpp"
#include "Tile.hpp"
#include "Corridor.hpp"
#include "Globals.hpp"
#include <vector>
#include <iostream>
#include <memory>
#include <vector>

Map::Map(){
    std::cout<<"Loading Map assets..."<<std::endl;
    this->floor_texture.loadFromFile("textures/floor.png");
    this->floor_texture.setRepeated(true);
}

void Map::draw(sf::RenderTarget& target, sf::RenderStates states)const{
    for(auto it:Rooms)
        target.draw(it,states);
}

void Map::Generate(){
    //generating rooms
    //basically its generating rooms, then corridor from it then next room etc
    int ammount_of_rooms = 2;
    sf::Vector2f start,end,position,place_room_here;
    place_room_here = sf::Vector2f(0.0,0.0);
    int position_of_corridor = 0;
    for(int i = 0; i<=ammount_of_rooms; i++){

        Room room;
        Corridor corridor;
        if(i>0){
            start = Rooms[Rooms.size()-1].GetValidExit(end);

            int direction_of_next_corridor = Rooms[i-1].GetDirectionOfExit();            
            int lenght = (std::rand()%10+4)*Globals::SCALE*16;
            bool colliding = false;

            while(colliding){
                colliding = false;
                for(auto it : Rooms){
                    colliding = it.WillCollide(direction_of_next_corridor,lenght,start);
                    if(colliding)
                        break;

                }
                for(auto it : Corridors){
                    colliding = it.WillCollide(direction_of_next_corridor,lenght,start);
                    if(colliding)
                        break;
                }
                if(colliding){
                    start = Rooms[i-1].GetValidExit(start);
                    direction_of_next_corridor = Rooms[i-1].GetDirectionOfExit();
                    lenght = (std::rand()%10+4)*Globals::SCALE*16;
                }

            }

            //1 top 2 right 3 down, its all clockwise
            //direction corridor., at the end of it we will generate a room
            Rooms[i-1].AddExit(start);
            bool generating = true;
            while(generating){

                switch(direction_of_next_corridor){
                    case 0:
                        end.y -= Globals::SCALE*16;
                        if(end.y == start.y - lenght){
                            place_room_here.y = start.y + lenght;
                            place_room_here.x = start.x;
                            generating = false;
                        }
                        break;
                    case 1:
                        end.x -= Globals::SCALE*16;
                        if(end.x == start.x - lenght){
                            place_room_here.x = start.x + lenght;
                            place_room_here.y = start.y;
                            generating = false;
                        }
                        break;
                    case 2:
                        end.y += Globals::SCALE*16;
                        if(end.y == start.y + lenght){
                            place_room_here.y = start.y + lenght;
                            place_room_here.x = start.x;
                            generating = false;
                        }
                        break;
                    case 3:
                        end.x += Globals::SCALE*16;
                        if(end.x == start.x + lenght){
                            place_room_here.x = start.x + lenght;
                            place_room_here.y = start.y;
                            generating = false;
                        }
                        break;
                }
            }
            corridor.GenerateCorridor(start,end);

            this->Corridors.emplace_back(corridor);

        }

        room.Generate(place_room_here,&floor_texture,position_of_corridor);
        if(i==0){
            end = room.GenerateLeftExit();
            room.AddExit(end);
        }
        this->Rooms.emplace_back(room);
    }
}

sf::Vector2f Map::Get_Spawn(){
    sf::Vector2f buffor;
    buffor.x = Rooms[0].Get_Top_Left_Corner().x+8*5;
    buffor.y = Rooms[0].Get_Top_Left_Corner().y+8*5;
    return buffor;
}

std::vector<sf::Vector2f> Map::Generate_Path(sf::Vector2f position){
    std::vector<sf::Vector2f> buffer;

    if(true)//check if mouse position is in the same room like from position
    return buffer;
}
